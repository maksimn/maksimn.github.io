При решении задачи использовалась методология test-driven development. Сначала писались тесты (файл shri_tests.js), потом код (shri.js). 

В основе архитектуры лежит класс SHRI. Он выполняет

1) роль фабрики для ВСЕХ остальных объектов системы: позволяет создавать студентов, команды, менторов и задачи (классы Student, Team, Mentor, Task). Предполагается, что каждый объект этих классов выделяется своим уникальным именем (свойство name), задаваемым через конструктор.

2) распределение студентов по менторам в конце обучения. Способ распределения описан в коде (файл shri.js, метод shri.distribute). Для этого внутри класса SHRI содержится список всех студентов и менторов школы.

Объединение студентов в команды происходит через создание фабрикой объектов команд и студентов и добавление студентов через вызов экземплярных методов Team.addStudent(student).

Индивидуальное задание -- объект класса Task, содержащийся во внутреннем списке tasks[] объекта класса Student; командное задание -- то же самое, но в классе Team. Общие поля и методы Student и Team выделены в базовый класс Subject ("Cубъект"). Задание определяется студенту или команде через вызов общего экземплярного метода addTask(task).

За выставление оценки за задание отвечает экземплярный метод Task.grade().

Каждый объект студента имеет приоретизированный список менторов (свойство prioritizedMentors[]). Каждый элемент этого списка содержит ссылку на ментора (свойство mentor) и значение его приоритета (свойство priority). Ментор добавляется через вызов Student.addMentor(), ссылку на ментора можно получить через Student.mentor(name), get- и set-метод для приоритета ментора -- Student.mentorPriority().

Для приоретизированных списков студентов у менторов -- та же структура с точностью до замены имен свойств и методов.

При выполнении задания никаких фреймворков использовано не было. В том числе это не делалось при написании тестов. Это можно отнести к минусам.

Примечание. Написанные тесты являются интеграционными, а не юнит-тестами, т.е. тестируют поведение системы в целом. Плюс здесь в том, что такой код тестов позволяет продемонстрировать примеры использования данного "SHRI API" в том виде, в каком он должен применяться при работе с ним. Код практически всех отдельных методов является весьма простым и написание специальных тестов для них не кажется необходимым. Исключением является алгоритм распределения студентов по менторам, для методов которого, возможно, стоило бы написать юнит-тесты. Однако, эти методы скрыты в области видимости внутри метода распределения distribute(), поэтому вызвать извне их нельзя. 